#!/usr/bin/env node
var Q = require('q');
var fs = require('fs');
var colors = require('colors');
var exec = require('child_process').exec;
var spawn = require('child_process').spawn;
var argv = require('minimist')(process.argv.slice(2));
var path = require('path');

var findup = require('findup-sync');

var available_colors = [
  'yellow',
  'cyan',
  'white',
  'magenta',
  'grey',
  'blue'
];

var env = ( typeof argv.env === 'string' ) ? path.resolve(argv.env) : findup('.env');
var childProcesses = ( typeof argv.config === 'string' ) ? path.resolve(argv.config) : findup('entry.json');

console.log('\nenv:\t%s\nconfig:\t%s\n', env, childProcesses);
 
if ( !childProcesses ) {
  console.error(('Unable to find local entry.json\n').red);
  process.exit(99);
}

childProcesses = require(childProcesses);

var completed = [];
return validateConfig(childProcesses)
.then(setEnv)
.then(spawnProcesses)
.then(pipeStdIn)
.fail(function( err ) {
  console.log(('Error: ' +  err.message).red);
});
 
function setEnv() {
  var deferred = Q.defer();

  if (!env) {
    deferred.resolve();
  } else {
    exec('source ' + env + ' && printenv', { cwd: env.replace(/\/.*/, '') }, function( err, stdout, stderr ) {
      if ( err ) {
        throw new Error(err);
      }

      stdout.split('\n').forEach(function( line ) {
        var parts = line.split('=');
        process.env[ parts[0] ] = parts[1];
      });

      deferred.resolve();
    });
  }

  return deferred.promise;
}

function commandExists(cp) {
  var deferred = Q.defer();

  exec('command -v ' + cp.spawn.command + ' >/dev/null 2>&1 || { echo >&2; exit 1; }', function (error, stdout, stderr) {
    if (error !== null) {
      deferred.reject(new Error('Command ' + cp.spawn.command + ' for handle ' + cp.handle + ' does not exist'));
    }
    deferred.resolve();
  });

  return deferred.promise;
}

function spawnProcess(cp, i) {
  // check to see if the bin exists
  return commandExists(cp)
  .then(function() {
    var deferred = Q.defer();
    cp.process = spawn(cp.spawn.command, cp.spawn.args);
    
    [ 'stdout', 'stderr' ].forEach(function( str ) {
      cp.process[ str ].on('data', function( data ) {
        process[ str ].write(
            data.toString('utf8')
            .replace(/(^|\n)([^\n]+)/g, function( match, group1, group2 ) {
              return group1 + ( cp.handle + ': ' )[available_colors[i % available_colors.length]] + group2;
            }));
      })
      .on('close', function ( code, signal ) {
        if (completed.indexOf(cp.handle) < 0) {
          completed.push(cp.handle);
          process[ 'stdout' ].write(('------------------\n')[available_colors[i % available_colors.length]]);
          process[ 'stdout' ].write(
            (cp.handle + ': completed\n' )[available_colors[i % available_colors.length]]
          );
          process[ 'stdout' ].write(('------------------\n')[available_colors[i % available_colors.length]]);

          childProcesses.forEach(function( cp2, i2 ) {
            if (cp2.hasOwnProperty('waitOn') && cp2.waitOn === cp.handle) {
              deferred.resolve(spawnProcess(cp2, i2));
            }
          });
        }
      });
    });
    return deferred.promise;
  });
}

function spawnProcesses() {
  // generic stdout & stderr
  return Q.all(
    childProcesses.map(function( cp, i ) {
      if (!cp.hasOwnProperty('waitOn')) {
        return spawnProcess(cp, i);
      }
    })
  );
}

function pipeStdIn() {
  process.stdin.resume();
  process.stdin.on('data', function( chunk ) {
    var s = chunk.toString('utf8');
    var cp = childProcesses.filter(function( cp ) {
      return typeof cp.stdinPrefix === 'string' && ( new RegExp('^' + cp.stdinPrefix + '\\.') ).test(s);
    })[ 0 ];
   
    if ( !cp ) {
      return console.log(('No target for input').red);
    }
   
    var cmd = s.substring(cp.stdinPrefix.length + 1);
    cp.process.stdin.write(cmd);
  });
}

function validateConfig(config) {
  var deferred = Q.defer();
  var handles = [];
  var stdinPrefixes = [];
  config.forEach(function (configItem, i) {
    // handle exists
    if ( !configItem.handle || configItem.handle.length === 0 ) {
      deferred.reject(new Error('Entry ' + i + ' has no handle. Handles are required.'));
    }

    // handle is unique
    if ( !!~handles.indexOf(configItem.handle) ) {
      deferred.reject(new Error(configItem.handle + ' is a handle for more than one entry. Handles must be unique.'));
    }

    // command exists
    if ( !configItem.spawn.command || configItem.spawn.command.length === 0 ) {
      deferred.reject(new Error('Entry ' + i + ' has no command. Commands are required.'));
    }

    // if there is a waitOn property, it isn't blank (if it is blank, it'll hang)
    if ( configItem.waitOn === "" ) {
      deferred.reject(new Error('waitOn for entry ' + i + ' is blank. Either remove the property or assign a value.'));
    }

    // if there is a waitOn property, it waits on a handle that exists
    if ( configItem.waitOn && !~handles.indexOf(configItem.waitOn) ) {
      deferred.reject(new Error('Entry ' + i + ' waits on handle ' + configItem.waitOn + ', which does not exist.'));
    }

    // if there is a stdinPrefix property, it isn't blank
    if ( configItem.stdinPrefix === "" ) {
      deferred.reject(new Error('stdinPrefix for entry ' + i + ' is blank. Either remove the property or assign a value.'));
    }

    // stdinPrefix is unique
    if ( configItem.stdinPrefix && !!~stdinPrefixes.indexOf(configItem.stdinPrefix) ) {
      deferred.reject(new Error(configItem.stdinPrefix + ' is a stdinPrefix for more than one entry. StdinPrefixes must be unique.'));
    }

    handles.push(configItem.handle);
    stdinPrefixes.push(configItem.stdinPrefix);
  });
  deferred.resolve(config);
  return deferred.promise;
}
